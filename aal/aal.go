package aal

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"crypto/subtle"
	"errors"
	"fmt"
	"hash"
	"io"
	"math/big"
)

// PublicKey represents an AAL public key, which is just an elliptic
// curve point behind the scenes. In order to be useful, the ID field
// has to be filled in by an out-of-band process and be unique to each
// public key.
type PublicKey struct {
	Curve elliptic.Curve
	X, Y  *big.Int
	ID    []byte
}

// Validate validates a public key.
func (p *PublicKey) Validate() error {
	if len(p.ID) == 0 {
		return errors.New("error: missing public key ID")
	}
	return nil
}

// PrivateKey represents an AAL public key, which is a PublicKey point
// and an integer.
type PrivateKey struct {
	PublicKey
	V *big.Int
}

// AAL represents all of the different functions possible with the AAL
// signcryption scheme.
type AAL interface {
	Signcrypt(sender *PrivateKey, recipient *PublicKey, plaintext, additionalData []byte) (*SigncryptionOutput, error)
	Verify(sender, recipient *PublicKey, additionalData []byte, output *SigncryptionOutput) (bool, error)
	Unsigncrypt(sender *PublicKey, recipient *PrivateKey, additionalData []byte, output *SigncryptionOutput) ([]byte, bool, error)
}

// GeneratePrivateKey generates a public key for an elliptic curve.
func GeneratePrivateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error) {
	ecdsaKey, err := ecdsa.GenerateKey(c, rand)
	if err != nil {
		return nil, fmt.Errorf("error generating ECDSA key: %s", err)
	}

	return &PrivateKey{
		PublicKey: PublicKey{
			Curve: c,
			X:     ecdsaKey.X,
			Y:     ecdsaKey.Y,
		},
		V: ecdsaKey.D,
	}, nil
}

type cipherCreator func([]byte) (cipher.Block, error)

type hashCreator func() hash.Hash

type signcrypter struct {
	securityLevel int
	curve         elliptic.Curve
	hashCreator   hashCreator
	cipherCreator cipherCreator
	rand          io.Reader
}

// SigncryptionOutput is the output generated by the signcryption
// process. All of it must be maintained in order to verify and
// unsigncrypt the data.
type SigncryptionOutput struct {
	R          []byte
	Ciphertext []byte
	Signature  []byte
}

func (s *signcrypter) Signcrypt(sender *PrivateKey, recipient *PublicKey, plaintext, additionalData []byte) (*SigncryptionOutput, error) {
	if err := sender.PublicKey.Validate(); err != nil {
		return nil, fmt.Errorf("error invalid public key: %s", err)
	}
	if err := recipient.Validate(); err != nil {
		return nil, fmt.Errorf("error invalid public key: %s", err)
	}

	prime := s.curve.Params().P
	nMod := s.curve.Params().N

	// choose random v
	vBytes := make([]byte, s.curve.Params().BitSize/8)
	if _, err := io.ReadFull(s.rand, vBytes); err != nil {
		return nil, fmt.Errorf("error reading from rand reader: %s", err)
	}
	v := new(big.Int).SetBytes(vBytes)
	v.Mod(v, new(big.Int).Sub(prime, big.NewInt(1)))

	// compute r
	// TODO: a 33 byte compressed version of R might make sense here.
	xR, yR := s.curve.ScalarBaseMult(v.Bytes())
	rMarshaled := elliptic.Marshal(s.curve, xR, yR)

	// compute point p
	p := new(big.Int).Add(v, sender.V)
	p.Mod(p, nMod)

	// compute Q
	xQ, yQ := s.curve.ScalarMult(recipient.X, recipient.Y, p.Bytes())

	// compute session key
	hash := s.hashCreator()
	hash.Write(xQ.Bytes())
	hash.Write(sender.ID)
	hash.Write(yQ.Bytes())
	hash.Write(recipient.ID)
	key := hash.Sum(nil)
	key = key[:s.securityLevel/8]

	// encrypt
	block, err := s.cipherCreator(key)
	if err != nil {
		return nil, fmt.Errorf("error creating AES cipher: %s", err)
	}
	ciphertext := make([]byte, len(plaintext))
	iv := make([]byte, block.BlockSize())
	if _, err := io.ReadFull(s.rand, iv); err != nil {
		return nil, fmt.Errorf("error reading random IV: %s", err)
	}
	ctr := cipher.NewCTR(block, iv)
	ctr.XORKeyStream(ciphertext, plaintext)
	ciphertext = append(iv, ciphertext...)

	// create tag
	hash = s.hashCreator()
	hash.Write(additionalData)
	hash.Write(iv)
	hash.Write(ciphertext)
	hash.Write(xR.Bytes())
	hash.Write(sender.ID)
	hash.Write(yR.Bytes())
	hash.Write(recipient.ID)
	t := new(big.Int).SetBytes(hash.Sum(nil))

	// create signature
	sig := new(big.Int).ModInverse(t, prime)
	sig.Mul(sig, p)
	sig.Mod(sig, prime)

	return &SigncryptionOutput{
		R:          rMarshaled,
		Ciphertext: ciphertext,
		Signature:  sig.Bytes(),
	}, nil
}

func (s *signcrypter) Verify(sender, recipient *PublicKey, additionalData []byte, output *SigncryptionOutput) (bool, error) {
	if err := sender.Validate(); err != nil {
		return false, fmt.Errorf("error invalid public key: %s", err)
	}
	if err := recipient.Validate(); err != nil {
		return false, fmt.Errorf("error invalid public key: %s", err)
	}

	// parse r
	xR, yR := elliptic.Unmarshal(s.curve, output.R)

	// extract IV
	iv := output.Ciphertext[:aes.BlockSize]
	ciphertext := output.Ciphertext[aes.BlockSize:]

	// compute tag
	hash := s.hashCreator()
	hash.Write(additionalData)
	hash.Write(iv)
	hash.Write(ciphertext)
	hash.Write(xR.Bytes())
	hash.Write(sender.ID)
	hash.Write(yR.Bytes())
	hash.Write(recipient.ID)
	t := hash.Sum(nil)

	// compute verification equation #1
	mX, mY := s.curve.ScalarBaseMult(output.Signature)
	vX1, vY1 := s.curve.ScalarMult(mX, mY, t)

	// compute verification equation #2
	vX2, vY2 := s.curve.Add(xR, yR, sender.X, sender.Y)

	xEqual := subtle.ConstantTimeCompare(vX1.Bytes(), vX2.Bytes())
	yEqual := subtle.ConstantTimeCompare(vY1.Bytes(), vY2.Bytes())

	return (xEqual == 0) && (yEqual == 0), nil
}

func (s *signcrypter) Unsigncrypt(sender *PublicKey, recipient *PrivateKey, additionalData []byte, output *SigncryptionOutput) ([]byte, bool, error) {
	if err := sender.Validate(); err != nil {
		return nil, false, fmt.Errorf("error invalid public key: %s", err)
	}
	if err := recipient.PublicKey.Validate(); err != nil {
		return nil, false, fmt.Errorf("error invalid public key: %s", err)
	}

	// verify the signature first
	valid, err := s.Verify(sender, &recipient.PublicKey, additionalData, output)
	if err != nil {
		return nil, false, fmt.Errorf("error validating signature: %s", err)
	}
	if !valid {
		return nil, false, nil
	}

	// parse r
	xR, yR := elliptic.Unmarshal(s.curve, output.R)

	// compute p & q
	xP, yP := s.curve.Add(xR, yR, sender.X, sender.Y)
	xQ, yQ := s.curve.ScalarMult(xP, yP, recipient.V.Bytes())

	// compute session key
	hash := s.hashCreator()
	hash.Write(xQ.Bytes())
	hash.Write(sender.ID)
	hash.Write(yQ.Bytes())
	hash.Write(recipient.ID)
	key := hash.Sum(nil)
	key = key[:s.securityLevel/8]

	// extract IV
	iv := output.Ciphertext[:aes.BlockSize]
	ciphertext := output.Ciphertext[aes.BlockSize:]

	// recover plaintext
	plaintext := make([]byte, len(ciphertext))
	block, err := s.cipherCreator(key)
	if err != nil {
		return nil, false, fmt.Errorf("error creating AES cipher: %s", err)
	}

	ctr := cipher.NewCTR(block, iv)
	ctr.XORKeyStream(plaintext, ciphertext)

	return plaintext, true, nil
}

// NewP256 returns an AAL instance based on the elliptic curve
// P256. The instance uses AES-CTR-128 for encrypting and SHA-256 for
// generating keys. This signcryption scheme provides security at the
// 128-bit level.
func NewP256() AAL {
	return newP256(rand.Reader)
}

func newP256(rand io.Reader) AAL {
	return &signcrypter{
		securityLevel: 128,
		curve:         elliptic.P256(),
		hashCreator:   sha256.New,
		cipherCreator: aes.NewCipher,
		rand:          rand,
	}
}

// NewP521 returns an AAL instance based on the elliptic curve
// P521. The signcrypter uses AES-CTR-512 for encrypting and SHA-512
// for generating keys. This signcryption scheme provides security at
// the 256-bit level.
func NewP521() AAL {
	return newP521(rand.Reader)
}

func newP521(rand io.Reader) AAL {
	return &signcrypter{
		securityLevel: 256,
		curve:         elliptic.P521(),
		hashCreator:   sha256.New,
		cipherCreator: aes.NewCipher,
		rand:          rand,
	}
}
